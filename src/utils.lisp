(in-package :utils)
(defmacro with-gensyms (symbols &body body)
  "Create gensyms for those symbols."
  `(let (,@(mapcar #'(lambda (sym)
		       `(,sym ',(gensym))) symbols))
     ,@body))
(defmacro doread((var stream) &body body)
  "Read character by character with the speed of line by line reading."
  (with-gensyms (line count len)
    `(do ((,line #1=(read-line ,stream nil nil) #1#))
	 ((null ,line))
       (do* ((,line (concatenate 'string ,line (format nil "~%~%")))
	     (,len (length ,line))
	     (,count 0 (1+ ,count))
	     (,var #2=(elt ,line ,count) #2#))
	    ((= (1- ,len) ,count))
	 ,@body))))
(defmacro once-only ((&rest names) &body body)
  "A macro-writing utility for evaluating code only once."
  (let ((gensyms (loop for n in names collect (gensym))))
    `(let (,@(loop for g in gensyms collect `(,g (gensym))))
       `(let (,,@(loop for g in gensyms for n in names collect ``(,,g ,,n)))
          ,(let (,@(loop for n in names for g in gensyms collect `(,n ,g)))
             ,@body)))))
(defmacro make-reader (name (stream-var dispatch-1 dispatch-2) &body body)
  (with-gensyms (sub-char numarg)
    `(progn (defun ,name (,stream-var ,sub-char ,numarg)
	(declare (ignore ,sub-char ,numarg))
	,@body)
	    (set-dispatch-macro-character ,dispatch-1 ,dispatch-2 #',name))))
(defun push-on (elem array)
  (let ((len (length array)))
    (adjust-array array (1+ len))
    (setf (elt array len) elem)
    array))
(defmacro dolines ((var path) &body body)
  (with-gensyms (s)
    `(with-open-file (,s ,path)
       (do ((,var (read-line ,s nil nil) (read-line ,s nil nil)))
	   ((null ,var))
	 ,@body))))
(defmacro aif ((it conditional) then &optional else)
  `(let ((,it ,conditional))
     (if ,it
	 ,then
	 ,else)))
(defmacro awhen ((it conditional) then)
  `(aif (,it ,conditional) ,then))
(defmacro abbrev (short long)
  `(defmacro ,short (&rest args)
     `(,',long ,@args)))
(abbrev mvbind multiple-value-bind)
(abbrev dbind destructuring-bind)
(defun list-directory (directory)
  (directory (merge-pathnames "*.*" directory)))
(defun length-lines (path)
  "Count up the number of lines in PATH."
  (with-open-file (s path)
    (labels ((inner (n)
               (if (read-line s nil nil nil)
                   (inner (1+ n))
                   n)))
      (inner 0))))
(defun nthline (n path &key from-end)
  "A line from path. Can also count backwards."
  (with-open-file (s path)
    (labels ((inner (line c)
               (if (> 0 c)
                   line
                   (let ((res (read-line s nil nil nil)))
                     (if res
                         (inner res (1- c))
                         (warn "End of file in ~A." path))))))
      (inner 0 (if from-end
                   (- (1- (length-lines path)) n)
                   n)))))
(defun run-line (code &key (output t) (ignore-error-status t))
  (uiop:run-program code :output output :ignore-error-status ignore-error-status))
(defun change-dir (dir code)
  (format nil "cd ~A && ~A" dir code))
(defmacro mapfns ((&rest args) &rest fns)
  "Map over functions in order with the same args. Return last."
  (with-gensyms (save prev fnl)
    `(labels ((,save (,prev ,fnl)
                (if (null ,fnl)
                    ,prev
                    (,save (funcall (car ,fnl) ,@args) (cdr ,fnl)))))
       (,save nil ',fns))))
(defun mkstr (&rest args)
  (with-output-to-string (s)
    (dolist (a args) (princ a s))))
(defun symb (&rest args)
  (values (intern (apply #'mkstr args))))
(defun drop (list index)
  "Remove item from a list."
  (labels ((inner (list index current acc)
             (if (null list)
                 (nreverse acc)
                 (if (= current index)
                     (inner (cdr list) index (1+ current) acc)
                     (inner (cdr list) index (1+ current) (cons (car list) acc))))))
    (inner list index 0 nil)))
;;; (only-one ((not t) t) 1) -> t
(defmacro only-one (conditions nth)
  "Only the nth condition can be true (eg. (and (not a) b (not c)))."
  `(and ,@(loop for x in (drop conditions nth)
                collect (list 'not x))
        ,(nth nth conditions)))
;;; (and (not (not t)) t)
(defun pack (thing)
  (if (consp thing)
      (list thing)
      thing))
