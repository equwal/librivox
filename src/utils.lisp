(in-package :utils)
(defmacro with-gensyms (symbols &body body)
  "Create gensyms for those symbols."
  `(let (,@(mapcar #'(lambda (sym)
		       `(,sym ',(gensym))) symbols))
     ,@body))
(defmacro doread((var stream) &body body)
  "Read character by character with the speed of line by line reading."
  (with-gensyms (line count len)
    `(do ((,line #1=(read-line ,stream nil nil) #1#))
	 ((null ,line))
       (do* ((,line (concatenate 'string ,line (format nil "~%~%")))
	     (,len (length ,line))
	     (,count 0 (1+ ,count))
	     (,var #2=(elt ,line ,count) #2#))
	    ((= (1- ,len) ,count))
	 ,@body))))
(defun length-lines (path)
  "Count up the number of lines in PATH."
  (with-open-file (s path)
    (labels ((inner (n)
               (if (read-line s nil nil nil)
                   (inner (1+ n))
                   n)))
      (inner 0))))
(defmacro once-only ((&rest names) &body body)
  "A macro-writing utility for evaluating code only once."
  (let ((gensyms (loop for n in names collect (gensym))))
    `(let (,@(loop for g in gensyms collect `(,g (gensym))))
       `(let (,,@(loop for g in gensyms for n in names collect ``(,,g ,,n)))
          ,(let (,@(loop for n in names for g in gensyms collect `(,n ,g)))
             ,@body)))))
(defmacro make-reader (name (stream-var dispatch-1 dispatch-2) &body body)
  (with-gensyms (sub-char numarg)
    `(progn (defun ,name (,stream-var ,sub-char ,numarg)
	(declare (ignore ,sub-char ,numarg))
	,@body)
	    (set-dispatch-macro-character ,dispatch-1 ,dispatch-2 #',name))))
(defun push-on (elem array)
  (let ((len (length array)))
    (adjust-array array (1+ len))
    (setf (elt array len) elem)
    array))
(defmacro dolines ((var path) &body body)
  (with-gensyms (s)
    `(with-open-file (,s ,path)
       (do ((,var (read-line ,s nil nil) (read-line ,s nil nil)))
	   ((null ,var))
	 ,@body))))
(defmacro aif ((it conditional) then &optional else)
  `(let ((,it ,conditional))
     (if ,it
	 ,then
	 ,else)))
(defmacro awhen ((it conditional) then)
  `(aif (,it ,conditional) ,then))
(defmacro abbrev (short long)
  `(defmacro ,short (&rest args)
     `(,',long ,@args)))
(abbrev mvbind multiple-value-bind)
(abbrev dbind destructuring-bind)
(defun list-directory (directory)
  (directory (merge-pathnames "*.*" directory)))
(defun run-line (code &key (output t) (ignore-error-status t))
  (uiop:run-program code :output output :ignore-error-status ignore-error-status))
(defun change-dir (dir code)
  (format nil "cd ~A && ~A" dir code))
(defun mkdir (path)
  (run-line (format nil "mkdir ~A" path)))
(defmacro mapfns ((&rest args) &rest fns)
  "Map over functions in order with the same args. Return last."
  (with-gensyms (save prev fnl)
    `(labels ((,save (,prev ,fnl)
                (if (null ,fnl)
                    ,prev
                    (,save (funcall (car ,fnl) ,@args) (cdr ,fnl)))))
       (,save nil ',fns))))
(defun mkstr (&rest args)
  (with-output-to-string (s)
    (dolist (a args) (princ a s))))
(defun symb (&rest args)
  (values (intern (apply #'mkstr args))))
(defun drop (list index)
  "Remove item from a list."
  (labels ((inner (list index current acc)
             (if (null list)
                 (nreverse acc)
                 (if (= current index)
                     (inner (cdr list) index (1+ current) acc)
                     (inner (cdr list) index (1+ current) (cons (car list) acc))))))
    (inner list index 0 nil)))
;;; (only-one ((not t) t) 1) -> t
(defmacro only-one (conditions nth)
  "Only the nth condition can be true (eg. (and (not a) b (not c)))."
  `(and ,@(loop for x in (drop conditions nth)
                collect (list 'not x))
        ,(nth nth conditions)))
;;; (and (not (not t)) t)
(defun pack (thing)
  (if (consp thing)
      (list thing)
      thing))
(defmacro dodir ((var dir &key files dirs) &body body)
  (once-only (dir)
    `(dolist (,var (cond (,dirs (subdirectories ,dir))
                         (,files (directory-files ,dir))))
       ,@body)))
(defun shuffle (x y &key (key-x #'identity) (key-y #'identity))
  "Interpolate lists x and y with the first item being from x."
  (cond ((null x) y)
        ((null y) x)
        (t (list* (funcall key-x (car x)) (funcall key-y (car y))
                  (shuffle (cdr x) (cdr y))))))
(defun interpol (obj lst &key (key #'identity))
  "Intersperse an object in a list."
  (shuffle lst (loop for #1=#.(gensym) in (cdr lst)
		     collect obj)
           :key-x key))
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun group (source n)
    (labels ((rec (source acc)
               (let ((rest (nthcdr n source)))
                 (if (consp rest)
                     (rec rest (cons
                                (subseq source 0 n)
                                acc))
                     (nreverse
                      (cons source acc))))))
      (if source (rec source nil) nil))))
;;; (defcollect setf 2)
;;; (setf *x* 1 *y* 2)
(defmacro defcollect (name collector argn)
  "Collect a bunch of args into multiple invocations of a funcion. One example
of this is setf/setq: (setf a b c d) -> (setf a b) (setf c d)"
  (with-gensyms (x args)
    `(defmacro ,name (&rest ,args)
       `(progn ,@(loop for ,x in (group ,args ,argn)
                       collect (cons ',collector ,x))))))
;;; (setf *x* 1) (setf *y* 2)
(defun flatten (x)
  (labels ((rec (x acc)
             (cond ((null x) acc)
                   ((atom x) (cons x acc))
                   (t (rec (car x) (rec (cdr x) acc))))))
    (rec x nil)))
(defun select (fn lst)
  "Return the first element that matches the function."
  (if (null lst)
      nil
      (let ((val (funcall fn (car lst))))
        (if val
            (values (car lst) val)
            (select fn (cdr lst))))))
(defun concat (type &rest list-or-string)
  "Flatten before concatenating the inputs."
  (labels ((concatenate-list (type list)
             "For flat lists."
             (labels ((inner (type list acc)
                        (if (null list)
                            acc
                            (inner type
                                   (cdr list)
                                   (concatenate type acc (car list))))))
               (inner type list ""))))
    (concatenate-list type (flatten list-or-string))))
(defun run-line* (code &optional (output *debug-io*) (dir *downloads-dir*))
  (run-line (change-dir dir code) :output output))
(defun run-line*-integer-output (code)
  (parse-integer (run-program (change-dir *downloads-dir* code)
			      :output :string) :junk-allowed t))
(defun wget (url &optional (stream *standard-output*) (tmp "/home/jose/wget-output"))
  (run-line* (format nil "wget '~A' --output-document='~A'" url tmp))
  (dolines (l tmp)
    (format stream "~A~%" l)))
(defun compose (&rest fns)
  (let ((fns (butlast fns))
	(fn1 (car (last fns))))
    (if fns
	(lambda (&rest args)
	  (reduce #'funcall fns :from-end t
		                :initial-value (apply fn1 args)))
	#'identity)))
