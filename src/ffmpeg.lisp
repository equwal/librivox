(in-package :librivox)
(defvar *max-seconds* (* 60 60 12))
(defvar *image-types* (list "jpg" "png"))
(defvar *archive-types* (list "m3u" "zip"))
(defvar *video-types* (list "mp4"))
(defvar *audio-types* (append (list "mp3") *archive-types*))
(defvar *text-types* (list "txt"))
(defvar *types* (list *image-types*
                      *archive-types*
                      *video-types*
                      *audio-types*
                      *text-types*))
(defvar *comletion-name* "completion.tmp")
(defgeneric book-down (path/link)
  (:documentation "Download a librivox audiobook."))
(defclass audio (t) ((path :accessor path)))
(defclass m3u (audio) ())
(defclass raw (audio) ())
(defclass mp3 (raw) ())
(defmethod book-down ((link raw))
  (wget link))
(defmethod book-down ((path m3u))
  (with-open-file (s path)
    (dolines (line s)
             (wget line))))
(defmacro unwind-prog1 (cleanup &body protected)
  `(unwind-protect (progn ,@protected) ,cleanup))
(defun delete-types (&optional more)
  (dolist (y (append *types* more))
    (run-line* (concat "rm *." y))))
(defun safe-exit (old-dir)
  (setf *downloads-dir* old-dir)
  (delete-types))
(defun filetype (dir &optional (typelist *archive-types*))
  (dolist (file (directory-files dir))
    (when (member file typelist :test #'string-equal)
      (pathname-type file))))
(defun convert (&key dir image input)
  "Download and convert one book."
  (let ((old-dir *downloads-dir*))
    (setf *downloads-dir* dir)
    (unwind-prog1
        (safe-exit old-dir)
      (book-down input)
      (ffmpeg (filetype dir) image))))
(defun standard-definition-temp (image duration n)
  (run-line* (format nil "ffmpeg -loop 1 -i ~A -t ~D -c mjpeg temp-~D.mp4"
		     image duration n)))
(defgeneric package-audio (type)
  (:documentation "Generate the long audio file to be split."))
(defmethod package-audio ((type mp3))
  (run-line* "ffmpeg -f concat -safe 0 -i concat.txt -c copy output1.mp3"))
(defgeneric split-audio (type duration n)
  (:documentation "Split audio into sizes acceptable by hoster."))
(defmethod split-audio ((type mp3) duration n)
  (run-line* (format nil "ffmpeg -ss ~D -t ~D -i output1.mp3 -c copy output-~D.mp3"
		     (* n *max-seconds*) duration n)))
(defgeneric overlay-audio (type n)
  (:documentation "Put audio over video of the still image."))
(defmethod overlay-audio ((type mp3) n)
  (run-line*
   (format nil "ffmpeg -i temp-~D.mp4 -i output-~:*~D.mp3 -c copy output-~:*~D.mp4"
           n)))
(defgeneric count-splits (type)
  (:documentation "The number of audio files of length *max-seconds*."))
(defmethod count-splits ((type mp3))
  (ceiling (/ (run-line*-integer-output "mp3info -p \"%S\" output1.mp3")
              *max-seconds*)))
(defgeneric make-concat (type)
  (:documentation "Generate concat.txt for ffmpeg."))
(defmethod make-concat ((type mp3))
  (run-line* "for f in *.mp3; do echo \"file '$f'\" >> concat.txt; done"))
(defun duration (n rem)
  (if (= n (1+ n))
      (* (1+ rem) *max-seconds*)
      *max-seconds*))
(defun cleanup-temp (n)
  (run-line* (format nil "rm temp-~D.mp4" n)))
(defun ffmpeg (type image)
  "Dangerously convert image and audio into video."
  (make-concat type)
  (package-audio type)
  (multiple-value-bind  (times rem) (count-splits type)
    (dotimes (n times)
      (let ((duration (duration n rem)))
	(standard-definition-temp n duration image)
        (split-audio type duration n)
	(overlay-audio type n)
        (cleanup-temp n)))))
(defmacro deftypep (name general &key (test 'string-equal))
  "Specific file type check."
  (with-gensyms (x)
    `(defun ,name (path)
       (some #'(lambda (,x) (funcall ',test (pathname-type path) ,x))
             ,general))))
(deftypep image-typep *image-types*)
(deftypep archive-typep *archive-types*)
(deftypep video-typep *video-types*)
(deftypep audio-typep *audio-types*)
(defun finished (contents)
  "Determine whether the directory contains finished videos."
  (some #'video-typep contents))
