(in-package :librivox)
(defvar *downloads-dir* "/run/media/raw-downloads/")
(defvar *max-seconds* (* 60 60 12))
(defvar *image-types* (list "jpg"))
(defvar *archive-types* (list "m3u"))
(defvar *video-types* (list "mp4"))
(defvar *audio-types* (append (list "mp3") *archive-types*))
(defvar *text-types* (list "txt"))
(defvar *types* (list *image-types*
                      *archive-types*
                      *video-types*
                      *audio-types*
                      *text-types*))
(defvar *comletion-name* "completion.tmp")
(defun run-line* (code &optional (output *debug-io*))
  (run-line (change-dir *downloads-dir* code) :output output))
(defun run-line*-integer-output (code)
  (parse-integer (run-program (change-dir *downloads-dir* code)
			      :output :string) :junk-allowed t))
(defun wget (url &optional (track-stream *standard-output*))
  (run-line* (format nil "wget -nc ~A" url))
  (print url track-stream))
(defgeneric book-down (path/link)
  :documentation "Download a librivox audiobook.")
(defclass audio (t) ())
(defclass raw (audio) ())
(defclass mp3 (raw) ())
(defclass m3u (audio) ())
(defmethod book-down ((link raw))
  (wget link))
(defmethod book-down ((path m3u))
  (with-open-file (s path)
    (dolines (line s)
             (wget line))))
(defmacro unwind-prog1 (cleanup &body protected)
  `(unwind-protect (progn ,@protected) ,cleanup))
(defun delete-types (&optional more)
  (dolist (y (append *types* more))
    (run-line* (concat "rm *." y))))
(defun safe-exit (old-dir)
  (setf *downloads-dir* old-dir)
  (delete-types))
(defun convert (&key dir image input)
  "Download and convert one book."
  (let ((old-dir *downloads-dir*))
    (setf *downloads-dir* dir)
    (unwind-prog1
     (safe-exit old-dir)
     (book-down input)
     (ffmpeg image))))
(defun standard-definition-temp (image duration n)
  (run-line* (format nil "ffmpeg -loop 1 -i ~A -t ~D -c mjpeg temp-~D.mp4"
		     image duration n)))
(defun package-audio ()
  (run-line* "ffmpeg -f concat -safe 0 -i concat.txt -c copy output1.mp3"))
(defun split-audio (duration n)
  (run-line* (format nil "ffmpeg -ss ~D -t ~D -i output1.mp3 -c copy output-~D.mp3"
		     (* n *max-seconds*) duration n)))
(defun overlay-audio (n)
  (run-line*
   (format nil "ffmpeg -i temp-~D.mp4 -i output-~:*~D.mp3 -c copy output-~:*~D.mp4"
           n)))
(defun duration (n rem)
  (if (= times (1+ n))
      (* (1+ rem) *max-seconds*)
      *max-seconds*))
(defun ffmpeg (image)
  "Dangerously convert image and audio into video."
  (run-line* "for f in *.mp3; do echo \"file '$f'\" >> concat.txt; done")
  (package-audio)
  (multiple-value-bind  (times rem)
      (ceiling (/ (run-line*-integer-output "mp3info -p \"%S\" output1.mp3")
                  *max-seconds*))
    (dotimes (n times)
      (let ((duration (duration n rem)))
	(standard-definition-temp n duration image)
        (split-audio duration n)
	(overlay-audio n)
	(run-line* (format nil "rm temp-~D.mp4" n))))))
(defmacro deftypep (name general &key (test 'string-equal))
  "Specific file type check."
  (with-gensyms (x)
    `(defun ,name (path)
       (some #'(lambda (,x) (funcall ',test (pathname-type path) ,x))
             ,general))))
(deftypep image-typep *image-types*)
(deftypep archive-typep *archive-types*)
(deftypep video-typep *video-types*)
(deftypep audio-typep *audio-types*)
(defun finished (contents)
  "Determine whether the directory contains finished videos."
  (some #'video-typep contents))
(defmacro dodir ((var dir &key files dirs) &body body)
  `(dolist (,var (cond (dirs (subdirectories ,dir))
                       (files (directory-files ))))
     ,@body))
(defun convert-all ()
  (dodir (dir *downloads-dir* :dirs t)
    (let ((contents (directory-files dir)))
      (cond ((not (finished contents))
             (convert :image (select #'image-typep contents)
		      :input (select #'audio-typep contents)
		      :dir dir))))))
