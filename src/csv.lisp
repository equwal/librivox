(in-package :csv)
(defun make-escape? (prev curr)
  (char= #\" prev curr)
  ;(char= #\\ prev)
  )
(defun end-token? (prev curr)
  (declare (ignore curr))
  (char= #\" prev))
(defun open? (prev curr)
  (declare (ignore curr))
  (char= #\" prev))
(let ((in nil)
      (escape nil))
  (setf (fdefinition 'switches)
	(lambda (prev curr str)
	  (if (null curr)
	      (progn (setf in nil escape nil) str)
	      (if in
		  (if escape
		      (progn (toggle escape) (push-on prev str))
		      (if (make-escape? prev curr)
			  (progn (toggle escape) str)
			  (if (end-token? prev curr)
			      (progn (toggle in) (push-on #\Nul str))
			      (push-on prev str))))
		  (if (open? prev curr)
		      (progn (toggle in) str)
		      str))))))
(defun splice (str &optional acc!)
  (if (string= "" str)
      (nreverse acc!)
    (let ((res (search (string #\Nul) str)))
      (splice (subseq str (1+ res)) (push (subseq str 0 res) acc!)))))
(make-reader my-csv (stream #\# #\!)
  (macrolet ((once (&body body) ``',,@body))
    (do ((prev #1= (read-char stream nil nil) curr)
	 (curr #1# #1#)
	 (str (make-array 0 :adjustable t :element-type 'character)
	      (switches prev curr str)))
	((and (char= curr #\#) (char= prev #\!)) (once (splice (switches nil nil str)))))))
(defun read-to-string (stream)
  (with-output-to-string (s)
    (dolines (line stream)
      (princ line s)
      (format s "~%"))))
(defun slurp-csv (path)
  (with-open-file (s path)
    (concatenate 'string "#!" (read-to-string s) "!#")))
